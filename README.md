# RubyRTL
RubyRTL is an experimental Ruby DSL that aims at :
- Describing Digital circuits in Ruby, at the RTL level
- Generating synth√©sizable VHDL for FPGAs or ASICs

## How to install ?
The recommanded version of RubyRTL is uploaded on RubyGems, so that can simply be installed on a Linux box, by typing (use of rvm recommended):
- gem install ruby_rtl

## How does it look ?

Let's build a simple digital system : a Ripple carry circuit. Using RubyRTL, we can elaborate much more complex circuits than this simple adders. At the register-transfer level, much more complex functions operating on complex data structures, are possible : imagine a video macroblocks on which several filters are applied, in a single clock cycle, or a processor pipline etc.

For the moment, let's build this adder, in a progessive manner !

### Basic signal assignments : 1-bit half adder circuit

We start by the Hello World of Digital Design : the Half adder. We recall that it built from  2 basic gates. That "block" can be then used in a hierarchical manner to build a adder operating on integers. This bottom-up approach is representative of Digital System Design : we can elaborate complex functions with a clever composition of such components, either hierarchically or using the intrinsic parallelism of digital circuit.

~~~ruby
  require_relative '../lib/ruby_rtl'

  include RubyRTL

  class HalfAdder < Circuit
    def initialize
      input  :a,:b
      output :sum
      output :cout

      assign(sum  <= a ^ b) #xor
      assign(cout <= a & b) #cout
    end
  end

  ha=HalfAdder.new

  compiler=Compiler.new
  compiler.compile ha # VHDL generated !
~~~

The generated code is then :

~~~vhdl
-- automatically generated by RubyRTL
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library ruby_rtl;
use ruby_rtl.ruby_rtl_package.all;

library halfadder_lib;
use halfadder_lib.halfadder_package.all;

entity halfadder_c is
  port (
    a : in  std_logic;
    b : in  std_logic;
    sum : out std_logic;
    cout : out std_logic);
end halfadder_c;

architecture rtl of halfadder_c is
begin

  sum <= (a xor b);
  cout <= (a and b);

end rtl;
~~~
## Hierarchical composition : 1-bit full adder

Here, we *reuse* 1-but half adder, to elaborate a 1-bit full adder. It now has an input carry and an output carry. The example show how to call such hierarchal components and glue them together.

~~~ruby
require 'ruby_rtl'

include RubyRTL

require_relative 'half_adder' # preceding circuit

class FullAdder < Circuit
  def initialize
    input  :a,:b,:cin
    output :sum,:cout

    component :ha1 => HalfAdder     # class...
    component :ha2 => HalfAdder.new # or ...obj

    assign(ha1.a <= a )
    assign(ha1.b <= b )
    assign(ha2.a <= cin)
    assign(ha2.b <= ha1.sum)
    assign(sum   <= ha1.sum)
    assign(cout  <= ha1.cout | ha1.cout)

  end
end
~~~

### Genericity : word-level adders

~~~ruby
require_relative 'ruby_rtl'

include RubyRTL

require_relative 'full_adder' #preceding circuit

class Adder < Circuit

  def initialize nbits
    input  :a    => nbits
    input  :b    => nbits
    output :sum  => nbits
    output :cout

    # create  components
    adders=[]
    for i in 0..nbits-1
      adders << component("fa_#{i}" => FullAdder)
    end

    # connect everything
    for i in 0..nbits-1
      assign(adders[i].a <= a[i])
      assign(adders[i].b <= b[i])
      if i==0
        #assign(adders[0].cin <= Bit(0)) # no carry in for FA_0
        assign(adders[0].cin <= 0)       # even better.
      else
        assign(adders[i].cin <= adders[i-1].cout)
      end
      # final sum
      assign(sum[i]        <= adders[i].sum)
    end
  end
end
~~~


## How does this DSL works ?
RubyRTL is an *internal DSL*. We can see it as a new language, embedded in Ruby syntax. It benefits from Ruby directly. However, such embedding needs a cautious resort to metaprogramming and introspection.

More to come here. Stay tuned !

## Contact
Don't hesitate to drop me a mail if you like RubyRTL, or found a bug etc.
I will try to do my best to consolidate, maintain and enhance RubyRTL.

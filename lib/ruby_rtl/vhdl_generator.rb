require_relative 'code'

module RubyRTL
  class VhdlGenerator < Visitor

    attr_accessor :code
    attr_accessor :entity
    attr_accessor :ios
    attr_accessor :archi_elements

    def generate circuit
      @code=Code.new
      @ios,@archi_elements=[],[]
      @sigs={}

      circuit.ast.each{|node| node.accept(self)}

      code << gen_ieee_header()
      code.newline
      code << gen_entity(circuit)
      code.newline
      code << gen_archi(circuit)
      code=clean_vhdl()
      puts code.finalize
      code.save_as "#{circuit.name.downcase}.vhd"
    end

    def clean_vhdl
      txt=code.finalize
      txt.gsub! /;(\s*)\)/,")"
      txt.gsub! /,(\s*)\)/,")"
      (code=Code.new) << txt
      return code
    end

    def gen_ieee_header
      header=Code.new
      header << "-- automatically generated by RubyRTL"
      header << "library ieee;"
      header << "use ieee.std_logic_1164.all;"
      header << "use ieee.numeric_std.all;"
      header
    end

    def gen_entity circuit
      entity=Code.new
      entity << "entity #{circuit.name}_c is"
      entity.indent=2
      entity << "port ("
      entity.indent=4
      if circuit.has_sequential_statements
        entity << "clk    : in std_logic;"
        entity << "sreset : in std_logic;"
      end
      ios.each{|io| entity << io}
      entity.indent=2
      entity << ");"
      entity.indent=0
      entity << "end #{circuit.name}_c;"
    end

    def gen_archi circuit
      archi=Code.new
      archi << "architecture rtl of #{circuit.name}_c is"
      archi.indent=2
      @sigs.each do |sig,name|
        archi << "signal #{name} : #{sig.type.accept(self)};"
      end
      archi.indent=0
      archi << "begin"
      archi.indent=2
      archi.newline
      archi_elements.each do |element|
        archi << element
      end
      archi.indent=0
      archi.newline
      archi << "end rtl;"
      archi
    end

    def visitComment comment,args=nil
      "-- #{comment.str}"
    end

    def visitInput input,args=nil
      @sigs[input] || input.name
    end

    def visitOutput output,args=nil
      @sigs[output] || output.name
    end

    def visitSigDecl decl,args=nil
      name=decl.name
      name.sub!(/@/,'')
      type=decl.sig.type.accept(self)
      case decl.sig
      when Input
        dir="in"
      when Output
        dir="out"
      when Sig
        @sigs.merge!(decl.sig => name)
      else
        raise "ERROR : visitSigDecl : neither input ou output"
      end
      ios << "#{name} : #{dir} #{type};"
    end

    def visitSig sig,args=nil
      sig.name
    end

    def visitTypeDecl decl,args=nil
    end
    # ====== body stuff ========
    # === statements ===
    def visitAssign assign,args=nil
      lhs=assign.lhs.accept(self)
      rhs=assign.rhs.accept(self)
      rhs=ruby_to_vhdl_cast(assign.lhs.type,rhs)
      archi_elements << "#{lhs} <= #{rhs};"
    end

    def ruby_to_vhdl_cast(type,expr)
      case expr
      when Integer
        puts "=> casting #{expr} to #{type}"
        case type
        when Bit
          ret=Bit(expr) # method
        when BitVector
          ret=BitVector(expr) # method
        else
          raise "DSL ERROR : ruby_to_vhdl_cast(#{type},#{expr}) NIY"
        end
      when String
        return expr
      else
        raise "DSL ERROR : ruby_to_vhdl_cast(#{type},#{expr}(#{expr.class})) NIY"
      end
      ret.accept(self)
    end

    def visitCompDecl comp_decl,args=nil
      comp=comp_decl.comp
      instance_name=comp_decl.name
      sig_decls=comp.ast.select{|node| node.is_a? SigDecl}
      inputs =sig_decls.select{|decl| decl.sig.is_a? Input}.map(&:sig)
      outputs=sig_decls.select{|decl| decl.sig.is_a? Output}.map(&:sig)

      instanciation=Code.new
      instanciation << "#{instance_name} : entity work.#{comp.name}_c"
      instanciation.indent=2
      instanciation << "port map("
      instanciation.indent=4
      inputs.each do |input|
        actual_sig_name="#{instance_name}_#{input.name}"
        @sigs.merge!({input => actual_sig_name})
        instanciation << "#{input.name} => #{actual_sig_name},"
      end
      outputs.each do |output|
        actual_sig_name="#{instance_name}_#{output.name}"
        @sigs.merge!(output => actual_sig_name)
        instanciation << "#{output.name} => #{actual_sig_name},"
      end
      instanciation.indent=2
      instanciation << ");"
      instanciation.indent=0
      instanciation.newline
      archi_elements << instanciation
    end
    #
    def visitSequential sequential,args=nil
      code=Code.new
      label=sequential.label
      code << "#{label} : process(clk)"
      code << "begin"
      code << "end;"
      code
    end

    # === expressions ===
    VHDL_OP={
      "&" => "and",
      "|" => "or",
      "^" => "xor"
    }
    def visitBinary bin,args=nil
      lhs=bin.lhs.accept(self)
      op=VHDL_OP[bin.op]
      rhs=bin.rhs.accept(self)
      "(#{lhs} #{op} #{rhs})"
    end

    # types
    def visitBit bit,args=nil
      "std_logic"
    end

    def visitBitVector bv,args=nil
      range="#{bv.size-1} downto 0"
      "std_logic_vector(#{range})"
    end

    def visitUint uint,args=nil
      range="#{uint.nb_bits-1} downto 0"
      "unsigned(#{range})"
    end

    # literals
    def visitInteger int,args=nil
      int
    end

    def visitBitLit bit_lit,args=nil
      "'#{bit_lit.val}'"
    end

    def visitBitVectorLit bit_lit,args=nil
      "\"#{bit_lit.val}\""
    end

  end
end

require_relative 'code'
require_relative 'visitor'

module RubyRTL

  class DSLPrinter < Visitor

    def print circuit
      code=Code.new
      code << "# code generated by DSL printer"
      if root=circuit.ast
        root.ios.each{|io| p io; code << io.accept(self)}
        root.decls.each{|decl| code << decl.accept(self)}
        code << root.body.accept(self)
        puts code.finalize
      end
    end

    def visitComment node,args=nil
    end

    def visitSig sig,args=nil
      sig.name
    end

    def visitInput input,args=nil
      input.name
    end

    def visitOutput output,args=nil
      output.name
    end

    def visitTypeDecl decl,args=nil
      definition=decl.definition.accept(self)
      return "typedef #{decl.name} => #{definition}"
    end

    def visitSigDecl decl,args=nil
      name=(sig=decl.sig).accept(self)
      type=sig.type.accept(self)
      if (values=$typedefs.values).include?(sig.type)
        idx=values.index(sig.type)
        type=$typedefs.keys[idx]
      end
      case sig
      when Input
        kind="input "
      when Output
        kind="output"
      when Sig
        kind="wire"
      end
      "#{kind} #{name} => #{type}"
    end

    def visitCompDecl decl,args=nil
      "component #{decl.name} => #{decl.comp}"
    end

    def visitCombinatorial comb,args=nil
      body=comb.body.accept(self)
      code=Code.new
      code << "combinatorial(#{seq.label}){"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    def visitSequential seq,args=nil
      body=seq.body.accept(self)
      code=Code.new
      code << "sequential(#{seq.label}){"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    # === statements
    def visitBody body,args=nil
      code=Code.new
      body.each{|stmt| code << stmt.accept(self,args)}
      code
    end

    def visitAssign node,args=nil
      lhs=node.lhs.accept(self)
      rhs=node.rhs.accept(self)
      "assign(#{lhs} <= #{rhs})"
    end

    def visitIf node,args=nil
      cond=node.cond.accept(self)
      body=node.body.accept(self)
      elsifs_=Code.new
      node.elsifs.collect{|elsif_| elsifs_ << elsif_.accept(self)}
      else_=node.else.accept(self) if node.else
      code=Code.new
      code << "if #{cond}{"
      code.indent=2
      code << body
      code.indent=0
      if elsifs_.size>0 or node.else
        code << "}"
      end
      code << elsifs_
      code << else_ if node.else
      code << "}" unless node.else or elsifs_.size>0
      code
    end

    def visitElse else_,args=nil
      body=else_.body.accept(self)
      code=Code.new
      code << "else {"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    def visitElsif elsif_,args=nil
      cond=elsif_.cond.accept(self)
      body=elsif_.body.accept(self)
      code=Code.new
      code << "elsif #{cond}{"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    # === fsm
    def visitFsm fsm,args=nil
      code=Code.new
      code << "fsm(#{fsm.name}){"
      code.indent=2
      code << fsm.body.accept(self)
      code.indent=0
      code << "}"
      code
    end

    def visitState state,args=nil
      code=Code.new
      code << "state(#{state.name}){"
      code.indent=2
      code << state.body.accept(self)
      code.indent=0
      code << "}"
      code
    end

    def visitNext node,args=nil
      "next_state #{node.name}"
    end

    # === expr ===
    def visitBinary node,args=nil
      lhs=node.lhs.accept(self)
      op=node.op
      rhs=node.rhs.accept(self)
      "(#{lhs} #{op} #{rhs})"
    end

    def visitUnary node,args=nil
      expr=node.expr.accept(self)
      "(#{node.op} #{expr})"
    end

    def visitFuncCall func,args=nil
      puts "visiting func call #{func.name}"
      name=func.name
      pp func.args
      argus=func.args.collect{|arg| arg.accept(self)}.join(',')
      "#{name}(#{argus})"
    end

    # === literals ===
    def visitLiteral node,args=nil
      node.val
    end

    def visitBitLit node,args=nil
      node.super.accept(self)
    end

    def visitIntLit lit,args=nil
      lit.val
    end

    def visitRIntLit lit,args=nil
      lit.val
    end

    def visitRUintLit lit,args=nil
      lit.val
    end
    # === types ===

    def visitBitType node,args=nil
      "bit"
    end

    def visitBitVectorType bvt,args=nil
      "bv#{bvt.size}"
    end

    def visitIntType node,args=nil
      "int#{node.bitwidth}"
    end

    def visitRIntType node,args=nil
      "rint#{node.bitwidth}"
    end

    def visitRUintType node,args=nil
      "ruint#{node.bitwidth}"
    end

    def visitUintType node,args=nil
    end

    def visitRecordType rec_type,args=nil
      items=[]
      rec_type.hash.each{|item,type|
        items << "#{item} => #{type}"
      }
      "Record(#{items.join(",")})"
    end
  end
end

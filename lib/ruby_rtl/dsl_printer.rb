require_relative 'code'
require_relative 'visitor'

module RubyRTL

  class DSLPrinter < Visitor

    def print circuit
      code=Code.new
      code << "# code generated by DSL printer"
      root=circuit.ast
      root.ios.each{|io| p io; code << io.accept(self)}
      root.decls.each{|decl| code << decl.accept(self)}
      code << root.body.accept(self)
      puts code.finalize
    end

    def visitComment node,args=nil
    end

    def visitSig sig,args=nil
      sig.name
    end

    def visitInput input,args=nil
      input.name
    end

    def visitOutput output,args=nil
      output.name
    end

    def visitTypeDecl node,args=nil

    end

    def visitSigDecl decl,args=nil
      name=(sig=decl.sig).accept(self)
      type=sig.type.accept(self)
      case sig
      when Input
        kind="input "
      when Output
        kind="output"
      end
      "#{kind} #{name} : #{type}"
    end

    def visitCompDecl decl,args=nil
      "component #{decl.name} => #{decl.comp}"
    end

    def visitCombinatorial comb,args=nil
      body=comb.body.accept(self)
      code=Code.new
      code << "combinatorial(#{seq.label}){"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    def visitSequential seq,args=nil
      body=seq.body.accept(self)
      code=Code.new
      code << "sequential(#{seq.label}){"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    # === statements
    def visitBody body,args=nil
      code=Code.new
      body.each{|stmt| code << stmt.accept(self,args)}
      code
    end

    def visitAssign node,args=nil
      lhs=node.lhs.accept(self)
      rhs=node.rhs.accept(self)
      "assign(#{lhs} <= #{rhs})"
    end

    def visitIf node,args=nil
      cond=node.cond.accept(self)
      body=node.body.accept(self)
      elsifs_=node.elsifs.collect{|elsif_| elsif_.accept(self)}
      else_=node.else.accept(self) if node.else
      code=Code.new
      code << "if #{cond}{"
      code.indent=2
      code << body
      code << elsifs_
      code << else_
      code.indent=0
      code << "}"
      code
    end

    def visitElse else_,args=nil
      body=else_.body.accept(self)
      code=Code.new
      code << "else {"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    def visitElsif elsif_,args=nil
      cond=elsif_.cond.accept(self)
      body=elsif_.body.accept(self)
      code=Code.new
      code << "elsif #{cond}{"
      code.indent=2
      code << body
      code.indent=0
      code << "}"
      code
    end

    # === fsm
    def visitFsm fsm,args=nil
      fsm.states.each do |name,state|
        state.accept(self)
      end
    end

    def visitState state,args=nil
      state.body.accept(self)
    end

    def visitNext node,args=nil
    end

    # === expr ===
    def visitBinary node,args=nil
      lhs=node.lhs.accept(self)
      op=node.op
      rhs=node.rhs.accept(self)
      "(#{lhs} #{op} #{rhs})"
    end

    def visitUnary node,args=nil
      expr=node.expr.accept(self)
      "(#{node.op} #{expr})"
    end

    # === literals ===
    def visitLiteral node,args=nil
      node.val
    end

    def visitBitLit node,args=nil
      node.super.accept(self)
    end

    def visitIntLit lit,args=nil
      lit.val
    end
    # === types ===

    def visitBitType node,args=nil
      "bit"
    end

    def visitBitVectorType bvt,args=nil
      "bv#{bvt.size}"
    end

    def visitIntType node,args=nil
      "int#{node.nb_bits}"
    end

    def visitUintType node,args=nil
    end

    def visitRecordType node,args=nil
    end
  end
end
